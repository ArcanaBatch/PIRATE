#!/usr/bin/env perl

# Pangenome construction using cd-hit to deflate clusters, all-vs-all BLAST, nested/single MCL clustering and reinflation.

use strict;
use warnings;

use Getopt::Long qw(GetOptions);
use Pod::Usage;
use Cwd 'abs_path';
use File::Basename;

# switch off buffering for real time feedback.
#$| = 1; 

# check dependencies - no version check.
my $cd_hit_bin = "";
my $cd_hit_est_bin = "";
my $blastp_bin = "";
my $blastn_bin = "";
my $mcl_bin = "";
my $make_blast = "";
my $mcxdeblast_bin = "";

$cd_hit_bin = "cdhit" if `command -v cdhit;`;
$cd_hit_bin = "cd-hit" if `command -v cd-hit;`;
$cd_hit_est_bin = "cd-hit-est" if `command -v cd-hit-est;`;
$cd_hit_est_bin = "cdhit-est" if `command -v cdhit-est;`;
$blastp_bin = "blastp" if `command -v blastp;`;
$blastn_bin = "blastn" if `command -v blastn;`;
$make_blast = "makeblastdb" if `command -v makeblastdb;`;
$mcl_bin = "mcl" if `command -v mcl;`;
$mcxdeblast_bin = "mcxdeblast" if `command -v mcxdeblast;`;

my $dep_err = 0;
foreach( $cd_hit_bin, $blastn_bin, $blastp_bin , $mcl_bin, $cd_hit_est_bin){
	if($_ eq "") { print "$_ command not found.\n"; $dep_err = 1 }
}
die "Dependencies missing.\n" if $dep_err == 1;

# Version

=head1  SYNOPSIS

	pangenome_construction.pl -i /path/to/fasta 

=head1 Descriptions
	
	-h|--help 			usage information
	-m|--man			man page 
	-i|--input			input fasta file [nucleotide/aa]
	-o|--output			output directory [default: input directory]
	-t|--threads		number of threads/cores used to use [default: 2]
	-s|--steps			% identity threshold to use for pangenome construction [default: 95]
	-p|--perc			% identity thresholds to use for pangenome construction [default: 50,60,70,80,90,95,98]
	-l|--loci			file containing loci and genome as seperate columns [required for core extraction during cdhit]
	-q|--quiet			switch off verbose
	-cdl|--cdlow		cdhit lowest percentage id [default: 98]
	-cds|--cdstep		cdhit step size [default: 0.5]
	-f|--flat			mcl inflation value [default:2]
	-r|--retain			do not delete temp files
	-n|--nucleotide		create pangenome on nucleotide sequence [default: amino acid]
	
...

=cut

# path to executing script
my $script_path = abs_path(dirname($0));

# switch off buffering
#$| = 1; # turn off buffering for real time feedback.

# command line options
my $man = 0;
my $help = 0;
my $quiet = 0;
my $retain = 0;
my $nucleotide = 0;
my $threads = 2; 

my $input_file = '';
my $output_dir = '';
my $loci_list = '';

my $perc = 95;
my $steps = '';
my $cd_low = 98;
my $cd_step = 0.5;
my $inflation_value = 1.5;

GetOptions(

	'help|?' 	=> \$help,
	'man' 		=> \$man,
	'input=s' 	=> \$input_file,
	'output=s'	=> \$output_dir,
	'threads=i'	=> \$threads,
	'steps=s'	=> \$steps,
	'perc=s'	=> \$perc,
	'cdlow|cdl=i' => \$cd_low,
	'cdstep|cds=f' => \$cd_step,
	'flat=f' 	=> \$inflation_value,
	'loci=s' 		=> \$loci_list,
	'quiet'		=> \$quiet,
	'retain' => \$retain,
	'nucleotide' => \$nucleotide,
	
) or pod2usage(2);
pod2usage(1) if $help;
pod2usage(-verbose => 2) if $man;

# expand input and output files/directories
$input_file = abs_path($input_file);
my $input_dir = dirname(abs_path($input_file));
$output_dir = $input_dir if $output_dir eq '';
$output_dir = abs_path($output_dir);

# make output directory if it doesn't exist. 
if( -d "$output_dir" ){ }
else{ unless ( mkdir "$output_dir" ) { die "could not make working directory in $output_dir\n" } }

# check for mandatory input arguments
pod2usage( {-message => q{input directory is a required arguement}, -exitval => 1, -verbose => 1 } ) if $input_dir eq ''; 

# check for presence of input/output directories.
pod2usage( {-message => "input directory:$input_dir is not a directory", -exitval => 1, -verbose => 1 } ) unless -d $input_dir; 
pod2usage( {-message => "output directory:$output_dir is not a directory", -exitval => 1, -verbose => 1 } ) unless -d $output_dir; 

# working variables
my @files = ($input_file);
my $no_files = scalar(@files);
my $sample = "";

# start time
my $time_start = time();

# idntify thresholds and check they are numeric
my @thresholds = ();
if( $steps eq "" ){ 
	@thresholds = ($perc);
}
else{ 
	@thresholds = split (/\,/, $steps);
	@thresholds = sort  {$a <=> $b} @thresholds;
}
for (@thresholds) { if ( $_ !~ /^\d+$/ ) { die "Threshold value $_ is not numeric.\n" } }

# check files exist and have correct suffix.
my @suffix_list = (".aa.fasta" , ".fasta" , ".fa" , ".fas");
for my $file( @files ){

	my $suffix_check = 0;
	for (@suffix_list){ $suffix_check = 1 if $file =~ /$_$/  }
	die "$file suffix not recognised\n" if $suffix_check == 0;

	die "file $file does not exist.\n" if !-f $file;
		
} 

# check for conflicts between cd-hit low and %id threshold
my $max_thresh = $thresholds[scalar(@thresholds)-1];
die "Lowest cd-hit threshold ($cd_low) is below blast % id value ($max_thresh)" if $cd_low < $max_thresh;

# parse and check loci list if passed via -l
my %loci;
my $no_loci = 0;
my $no_genomes = 0;
if( $loci_list ne '' ){
	$loci_list = abs_path($loci_list);
	die "loci_list file not found.\n" unless -f $loci_list;
	open LOCI, "$loci_list" or die $!;
	while (<LOCI>){	
		if(/^(\S+)\t(\S+)\t/){ 
			$loci{$1}=$2;
		}
	}	
	$no_loci = scalar ( keys(%loci) );
	my %no_g = map {$_ => 1} values(%loci);
	$no_genomes =  scalar( keys (%no_g) );
}

# user feedback
if ($quiet == 0 ){
	print "Creating pangenome on nucleotide % identity.\n" if $nucleotide == 1;
	print "Creating pangenome on amino acid % identity.\n" if $nucleotide == 0;
	print "Input directory:\t$input_dir\n";
	print "Output directory:\t$output_dir\n";
	print "Number of input files: $no_files\n";
	print "Threshold(s): @thresholds\n";
	print "MCL inflation value: $inflation_value\n";
	print "Loci file contains $no_loci loci from $no_genomes genomes.\n" if $loci_list ne '';
	print "\n";
}

# variables for user feedback
my $processed = 0;
my $no_processed = 0;

# process files sequentially
for my $file( @files ){

	++$processed;	
	
	# find sample name
	my ($sample, $s_path, $suffix) = fileparse($file , @suffix_list);
	
	
	# create core file.
	my %core = ();
	open CORE1, ">$output_dir/$sample.core_clusters.tab" and close CORE1 or die "couldn't open $sample.core_clusters.tab\n";
	
	# feedback
	#$no_processed = sprintf ( "%.2f%s", ( ($processed / $no_files) * 100 ), "\%" );
	#print "\r - $no_processed  - Opening $sample" if $quiet == 0;
	print " - Opening $sample\n" if $quiet == 0;
	
	# make temp fasta sequence without alignment characters and single line.
	my @seq = ();
	my @seq_out = ();
	my $header = "";
	my @g_lengths = ();
	my $temp_seq = "";

	open FILE, "$file" or die "$file not found.\n";
	while(<FILE>){
		
		my $line = $_;
		$line =~ s/\R//g;
				
		if(/^>/){
						
			unless( scalar(@seq) == 0 ){
				$temp_seq = join( "" , @seq );
				push ( @seq_out, join("\n" , $header , $temp_seq) );
				push ( @g_lengths, length($temp_seq) );
			}	
				
			$header = $line;	
			@seq = ();
			
		}else{
		
			$line =~ s/\-//g;
			push( @seq, $line );
			
		}
	}close FILE;
		
	# store final sample
	$temp_seq = join("" , @seq);
	push ( @seq_out, join("\n" , $header , $temp_seq) );
	push ( @g_lengths, length( $temp_seq ));

	# sort file on length.
	my @idx = sort { $g_lengths[$b] <=> $g_lengths[$a] } 0 .. $#g_lengths;
	
	# Print to all sequences file.
	open TEMP, ">$output_dir/$sample.all_sequences.fasta" or die $!;
	print TEMP join("\n", @seq_out[@idx]);
	
	# number of sequences in file.
	my $no_sequences = scalar ( @seq_out ); 
	
	# cluster files using CD-Hit.
	my %cluster_hash = ();
	
	# make cd-hit log file.
	my $cdhit_log = "$output_dir/$sample.cdhit_log.txt";
	open CD_LOG, ">$cdhit_log" or die $!;
	
	# run at multiple thresholds.
	`cp $output_dir/$sample.all_sequences.fasta $output_dir/$sample.temp.fasta`;
	my $no_reduced = 0;
	#print "\r - $no_processed  - running cd hit on $sample" if $quiet == 0;
	print "\r - running cd hit on $sample" if $quiet == 0;
	
	for (my $i = 100; $i >= $cd_low; $i -= $cd_step) {	   		 
	
		my $curr_thresh = $i/100;
		
		# calculate memory for cdhit
		my $m_required = -s "$output_dir/$sample.temp.fasta";
		$m_required = int($m_required/1000000); #Mb
		$m_required *= 3; # triple
		$m_required = 2000 if($m_required < 2000); # set lowest
		
		# run cdhit
		print "\r - running cd hit on $sample at $i    " if $quiet == 0;
		if( $nucleotide == 0 ){
			`$cd_hit_bin -i $output_dir/$sample.temp.fasta -o $output_dir/$sample.$i -c $curr_thresh -T $threads -c 1 -g 1 -n 5 -M $m_required -d 256 >> $cdhit_log`;
		}else{
			`$cd_hit_est_bin -i $output_dir/$sample.temp.fasta -o $output_dir/$sample.$i -c $curr_thresh -T $threads -c 1 -g 1 -n 5 -M $m_required -d 256 >> $cdhit_log`;
		}
		die "cdhit failed.\n" if $?;
		
		# variables
		my $c_header="";
		my $define = 0;
		my @include_seq = ();
		my $seed_cluster = "";
		my $current_cluster = "";
		
		my %temp_clusters = ();
		my $c_name = "";
	
		open CLUSTER, "$output_dir/$sample.$i.clstr" or die $!;
		while(<CLUSTER>){
	
			# Add clustered loci to storage hash.
			if(/^>(.+)*/){

				$define = 0; 
				$c_name = $1;

			}elsif( /^\d+\s+/ ){
			
				$_ =~ /\s+\>(\S+)\.\.\./;
				$temp_clusters{$c_name}{$1} = 1;					
										
			}else{
				die "$_ did not match cd-hit format.\n";
			}
			
			# Add first hit to array of sequences to include.
			if( /^0\s+/ ){ 
			
				$_ =~ /\s+\>(\S+)\.\.\./;
				$seed_cluster = $1;
				push(@include_seq, $seed_cluster);	
				
			}
		}
		
		# Assign each loci to a prexisting or new cluster (named numerically).
		for my $clust(keys (%temp_clusters)){
		
			# clusters with >1 isolate have been deflated.
			unless( scalar(keys %{$temp_clusters{$clust}} ) == 1){
			
				# reset variables
				my $temp_name = "";
				my %temp_hash = ();
				my $recluster = 0;
				
				# Check for isolates in the current cluster having been previously assigned to a cluster.
				for my $c_iso( keys %{$temp_clusters{$clust}} ){
				
					if ( $cluster_hash{$c_iso} ){
						$temp_name = $cluster_hash{$c_iso};
						$temp_hash { $cluster_hash{$c_iso} } = 1;
						$recluster = 1;
					}
					
				}
		
				# Reassign isolates from clusters from previously iterations that cluster with this isolate.
				# Assign clusters from current cluster.
				if ( $recluster == 1 ){
					
					$no_reduced++;
					$temp_name = $no_reduced;
					
					# previous iteration clusters reassigned.
					for my $t ( keys ( %temp_hash ) ){
						for my $c_iso( keys %cluster_hash ){
						
							if ( $cluster_hash {$c_iso} == $t ){
								$cluster_hash {$c_iso} = $temp_name;
							}
							
						}
					}
					
					# current iteration clusters assigned.
					# Assign all isolates to new cluster.
					for my $c_iso(keys %{$temp_clusters{$clust}}){
						$cluster_hash{$c_iso} = $temp_name;
					}
					
				}else{
				
					# If no previously assigned cluster then provide a new cluster name.
					$no_reduced++;
					$temp_name = $no_reduced;
					
					# Assign all isolates to new cluster.
					for my $c_iso(keys %{$temp_clusters{$clust}}){
						$cluster_hash{$c_iso} = $temp_name;
					}
						
				}
			}
		}
		
		# check for core gene clusters i.e. in 100% of genomes.
		if( $loci_list ne '' ){
			
			# variables
			my %cluster_genomes = ();
			my %cluster_count = ();
			
			# count no of genes and no of genomes
			for my $l( keys %cluster_hash ){
		
				die "no genome found for loci $l\n" if !$loci{$l};
				$cluster_genomes { $cluster_hash{$l} }{ $loci{$l} }++;
				$cluster_count { $cluster_hash{$l} } { $l } = 1 ;
				
			}			
			
			# Identify core clusters.
			open CORE2, ">>$output_dir/$sample.core_clusters.tab" or die "couldn't open $sample.core_clusters.tab\n";
			for my $lc ( keys %cluster_genomes ){
				
				my $c_count = scalar(keys($cluster_genomes{$lc}));
				my $g_count = scalar(keys($cluster_count{$lc}));
				
				if( ( $c_count == $no_genomes ) && ( $g_count == $no_genomes) ){
					
					# add to core_clusters.tab file.					
					my $core_out = join ( "\t" , keys(%{$cluster_count{$lc}}));
					print CORE2 "$core_out\n";
					
					# add to core_hashand remove from cluster hash.
					foreach ( keys %{$cluster_count{$lc}} ){
						$core{$_} = $lc;
						delete $cluster_hash{$_};
					}
					
			
				}
				
			}close CORE2;
			
			
			# remove core loci from include seq.
			my @temp_seq = ();
			foreach(@include_seq){
							
				if( !$core{$_} ){
					push(@temp_seq, $_);
				}
				
			}
			@include_seq = @temp_seq;	
			
		}
		
		open INCLUDE, ">$output_dir/$sample.$i.include" or die $!; 
		print INCLUDE join("\n", @include_seq),"\n";
		
		# create new working fasta 
		`grep -A 1 -f $output_dir/$sample.$i.include < $output_dir/$sample.temp.fasta | grep -v "^--" > $output_dir/$sample.temp2.fasta`;
		`mv $output_dir/$sample.temp2.fasta $output_dir/$sample.temp.fasta`;
		`mv $output_dir/$sample.$i.include $output_dir/$sample.included`;
	
	}
	close CD_LOG;
	print "\n" if $quiet == 0;
	
	my $check_clusters = 0;
	open INCLUDE, "$output_dir/$sample.included" or die $!;
	open CLUSTERS, ">$output_dir/$sample.clusters" or die $!;
	while(<INCLUDE>){
			
		if(/^(\S+)*/){
		
			my $cluster_seed = $1;
			
			# if the sample is in a cluster then print all isolates in cluster.
			if ( $cluster_hash{$cluster_seed} ){
			
				my $c_tag = $cluster_hash{$cluster_seed};
				
				my @out_array = ();
				for my $inc( keys %cluster_hash ){
					if( $cluster_hash{$inc} == $c_tag ){
						push(@out_array, $inc);
						$check_clusters++;
					}
				}
				
				# print to file.
				my $out_line = sprintf( "%s\t$c_tag\t%s\n", $cluster_seed, join("\t", @out_array) );
				print CLUSTERS $out_line;
			
			}else{
				
				print CLUSTERS "$cluster_seed\t-\t$cluster_seed\n";
				$check_clusters++;	
			}
		
		}
	}
	
	# check number of stored clusters equals number of starting sequences.
	my $core_cluster_no = scalar( keys %core );
	die "number of sequences clustered via cd-hit (", ($check_clusters+$core_cluster_no) ,") does not match number of input sequences ($no_sequences)" if ($check_clusters+$core_cluster_no) != $no_sequences;
	
	# all vs all blast
	#print "\r - $no_processed  - running blast on $sample" if $quiet == 0;
	my $blast = "$output_dir/$sample.blast.out";
	
	if( $nucleotide == 0 ){
		print " - running all-vs-all blastp on $sample\n" if $quiet == 0;
		`makeblastdb -in $output_dir/$sample.temp.fasta -dbtype prot`;
		`$blastp_bin -task "blastp" -outfmt 6 -num_threads $threads -max_hsps 1 -query $output_dir/$sample.temp.fasta -db $output_dir/$sample.temp.fasta -out $blast`; # -evalue 1E-6 -max_target_seqs 2000
		die "blastp failed.\n" if $?; 
	}else{
		print " - running all-vs-all blastn on $sample\n" if $quiet == 0;
		`makeblastdb -in $output_dir/$sample.temp.fasta -dbtype nucl`;
		`$blastn_bin -task "blastn" -outfmt 6 -num_threads $threads -dust no -max_hsps 1 -query $output_dir/$sample.temp.fasta -db $output_dir/$sample.temp.fasta -out $blast`; # -evalue 1E-6 -max_target_seqs 2000
		die "blastn failed.\n" if $?; 
	}
	
	# reformat to abc 
	#`awk '{print \$1, \$2, \$3}' < $blast > $output_dir/$sample.abc_blast`;

	# Filter BLAST files at all thresholds and preform MCL on filtered hits.
	# Iterate through all clusters at higher thresholds.
	print " - running mcl on $sample" if $quiet == 0;
	my $previous_clusters = ""; 
	for my $c(0..(scalar(@thresholds)-1) ){
	
		my $threshold = $thresholds[$c];
		
		# feedback
		##print "\r - $no_processed  - running mcl on $sample at $threshold" if $quiet == 0;
		print "\r - running mcl on $sample at $threshold    " if $quiet == 0;
		
		# filter blast results on threshold.
		`awk '{if(\$3 >= $threshold){print \$0}}' < $blast > $output_dir/$sample.$threshold.blast`;
		#`awk '{if(\$3 >= $threshold){print \$1, \$2, \$11/\$4 }}' < $blast > $output_dir/$sample.abc_$threshold.blast`;
				
		if( $threshold ==  $thresholds[0] ){
	
			# reformat to abc and run mcl on bitscores normalised by hsp length
			`$mcxdeblast_bin --line-mode=abc --m9 --score=r $output_dir/$sample.$threshold.blast 2>/dev/null | $mcl_bin - --abc -te $threads -I $inflation_value -o $output_dir/$sample.mcl_$threshold.clusters 2>/dev/null`;
			#`$mcl_bin $output_dir/$sample.abc_$threshold.blast --abc -te $threads -I $inflation_value -o $output_dir/$sample.mcl_$threshold.clusters 2>/dev/null`;
			die "mcl failed at $threshold" if $?;
			
			# set working file for next iteration
			$previous_clusters = "$output_dir/$sample.mcl_$threshold.clusters";
		
		}else{
		
			# make mcl cluster file.
			`echo -n "" > $output_dir/$sample.mcl_$threshold.clusters`;
			
			# run mcl on each subcluster independently.
			open CLUSTERS, "$output_dir/$sample.mcl_$thresholds[$c-1].clusters" or die $!;
			while (<CLUSTERS>){
				
				# make loci into hash.
				my $line = $_;
				chomp $line;
				my @loci = split(/\s+/, $line);
				my %loci_hash= ();
				foreach( @loci ){ $loci_hash{$_} = 1 };
				
				# filter blast on threshold and only include samples in the cluster.
				#open ABC, "$output_dir/$sample.abc_$threshold.blast" or die $!;
				#open ABC_SUB, ">$output_dir/$sample.abc_$threshold.temp_sub.blast" or die $!;
				open ABC, "$output_dir/$sample.$threshold.blast" or die $!;
				open ABC_SUB, ">$output_dir/$sample.$threshold.temp_sub.blast" or die $!;
				while(<ABC>){
					if(/^(\S+)\s+(\S+)\s+/){				
						if( $loci_hash{$1} && $loci_hash{$2} ){
							print ABC_SUB $_;
						}
					}
				}
				close ABC;
				close ABC_SUB;
				
				# run mcl on sub-sampled abc blast file.
				`$mcxdeblast_bin --line-mode=abc --m9 --score=r $output_dir/$sample.$threshold.temp_sub.blast 2>/dev/null | $mcl_bin - --abc -te $threads -I $inflation_value -o $output_dir/$sample.mcl_$threshold.temp.clusters 2>/dev/null`;
				#`$mcl_bin $output_dir/$sample.abc_$threshold.temp_sub.blast --abc -te $threads -I $inflation_value -o $output_dir/$sample.mcl_$threshold.temp.clusters 2>/dev/null`;
				die "mcl failed at $threshold - line:\n$line\n" if $?;
				
				# add to existing file
				`cat $output_dir/$sample.mcl_$threshold.clusters $output_dir/$sample.mcl_$threshold.temp.clusters > $output_dir/temp.txt`;
				`mv $output_dir/temp.txt $output_dir/$sample.mcl_$threshold.clusters`;
				
				# set working file for next iteration
				$previous_clusters = "$output_dir/$sample.mcl_$threshold.clusters";
							
			}close CLUSTERS;
		}
	}
	print "\n" if $quiet == 0;
	
	# Reinflate clusters
	##print "\r - $no_processed  - reinflating clusters for $sample" if $quiet == 0;
	print " - reinflating clusters for $sample" if $quiet == 0;
	for my $t(@thresholds){
		
		# open output
		open INFLAT, ">$output_dir/$sample.$t.reclustered.reinflated" or die $!;
		
		# open input
		open CR, "$output_dir/$sample.mcl_$t.clusters" or die $!;

		# sanity check on number of output sequences.
		my $seq_count = 0;
		
		# loop through all clusters and reinflate where appropriate.
		while (<CR>){
			
			my $line = $_;
			$line =~ s/\R//;
			
			my @clusters_reinflated = ();
			
			foreach my $inflat( split(/\t/ , $line) ){
				
				# if cluster was previsously deflated with cd-hit add in missing loci.				
				if( !$cluster_hash{$inflat} ){
					push(@clusters_reinflated, $inflat);
				}
				else{	
					my $index  = $cluster_hash{$inflat};	
					foreach(keys %cluster_hash){
						if ( $cluster_hash{$_} == $index ){
							push(@clusters_reinflated, $_);
						}
					}					
				}
			}
			
			# increase count of sequences in file.
			my $out_clusters = join ("\t", @clusters_reinflated);
			my $number_in_cluster = scalar (@clusters_reinflated);

 			$seq_count = $seq_count + $number_in_cluster;
 			
			#print "@clusters_reinflated\n";			
			print INFLAT join ("\t", @clusters_reinflated), "\n";			

		}				
		close INFLAT;
		close CR;
		
		# add core clusters
		`cat $output_dir/$sample.core_clusters.tab $output_dir/$sample.$t.reclustered.reinflated > $output_dir/temp.txt`;
		`mv $output_dir/temp.txt $output_dir/$sample.$t.reclustered.reinflated`;
		
		# check number of clusters in final file matches input.
		die "Reinflated sequences (", ($seq_count+$core_cluster_no) , ") does not match input number of sequences ($no_sequences) at $t threshold in sample $sample.\n" if ($seq_count+$core_cluster_no) != $no_sequences;
		
	}
	
	# clean up temporary files
	unless ( $retain == 1 ){
	
		unlink "$output_dir/$sample.all_sequences.fasta";
		unlink "$output_dir/$sample.included";
		unlink "$output_dir/$sample.cdhit_log.txt";
		unlink "$output_dir/$sample.abc_blast";
		unlink "$output_dir/$sample.blast.out";
		unlink "$output_dir/$sample.clusters";
		unlink "$output_dir/$sample.temp.fasta";
		unlink sprintf ("$output_dir/$sample.mcl_%i.temp.clusters", $thresholds[scalar(@thresholds)-1] );
		
		if ( $nucleotide == 0 ){
			unlink "$output_dir/$sample.temp.fasta.phr";
			unlink "$output_dir/$sample.temp.fasta.pin";
			unlink "$output_dir/$sample.temp.fasta.psq";
		}else{
			unlink "$output_dir/$sample.temp.fasta.nhr";
			unlink "$output_dir/$sample.temp.fasta.nin";
			unlink "$output_dir/$sample.temp.fasta.nsq";
		}
	
		for (@thresholds){ 
			unlink "$output_dir/$sample.abc_$_.blast";
			unlink "$output_dir/$sample.abc_$_.temp_sub.blast";
			unlink "$output_dir/$sample.mcl_$_.clusters";
			unlink "$output_dir/$sample.mcl_$_.temp.clusters" if -f "$output_dir/$sample.mcl_$_.temp.clusters";
		}
	
		for (my $j = 100; $j >= $cd_low; $j -= $cd_step) {	
			unlink "$output_dir/$sample.$j";
			unlink "$output_dir/$sample.$j.clstr";
	
		}
		
	}
	
}
print "\n - Finished\n" if $quiet == 0;


exit
