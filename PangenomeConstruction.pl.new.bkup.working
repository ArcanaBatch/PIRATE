#!/usr/bin/env perl

# Pangenome construction using cd-hit to deflate clusters, all-vs-all BLAST, nested/single MCL clustering and reinflation.

use strict;
use warnings;

use Getopt::Long qw(GetOptions);
use Pod::Usage;
use Cwd 'abs_path';
use File::Basename;

# check dependencies - no version check.
my $cd_hit_bin = "";
my $cd_hit_est_bin = "";
my $blastp_bin = "";
my $blastn_bin = "";
my $mcl_bin = "";
my $make_blast = "";
my $mcxdeblast_bin = "";

$cd_hit_bin = "cdhit" if `command -v cdhit;`;
$cd_hit_bin = "cd-hit" if `command -v cd-hit;`;
$cd_hit_est_bin = "cd-hit-est" if `command -v cd-hit-est;`;
$cd_hit_est_bin = "cdhit-est" if `command -v cdhit-est;`;
$blastp_bin = "blastp" if `command -v blastp;`;
$blastn_bin = "blastn" if `command -v blastn;`;
$make_blast = "makeblastdb" if `command -v makeblastdb;`;
$mcl_bin = "mcl" if `command -v mcl;`;
$mcxdeblast_bin = "mcxdeblast" if `command -v mcxdeblast;`;

my $dep_err = 0;
foreach( $cd_hit_bin, $blastn_bin, $blastp_bin , $mcl_bin, $cd_hit_est_bin){
	if($_ eq "") { print "$_ command not found.\n"; $dep_err = 1 }
}
die "Dependencies missing.\n" if $dep_err == 1;

# Version

=head1  SYNOPSIS

	pangenome_construction.pl -i /path/to/fasta 

=head1 Descriptions
	
	-h|--help 			usage information
	-m|--man			man page 
	-i|--input			input fasta file [nucleotide/aa]
	-o|--output			output directory [default: input directory]
	-t|--threads		number of threads/cores used to use [default: 2]
	-s|--steps			% identity threshold to use for pangenome construction [default: 95]
	-p|--perc			% identity thresholds to use for pangenome construction [default: 50,60,70,80,90,95,98]
	-l|--loci			file containing loci and genome as seperate columns [required for core extraction during cdhit]
	-q|--quiet			switch off verbose
	-cdl|--cdlow		cdhit lowest percentage id [default: 98]
	-cds|--cdstep		cdhit step size [default: 0.5]
	-f|--flat			mcl inflation value [default:2]
	-r|--retain			do not delete temp files
	-n|--nucleotide		create pangenome on nucleotide sequence [default: amino acid]
	
...

=cut

# path to executing script
my $script_path = abs_path(dirname($0));

# switch off buffering
$| = 1; # turn off buffering for real time feedback.

# command line options
my $man = 0;
my $help = 0;
my $quiet = 0;
my $retain = 0;
my $nucleotide = 0;
my $threads = 2; 

my $input_file = '';
my $output_dir = '';
my $loci_list = '';

my $perc = 95;
my $steps = '';
my $cd_low = 98;
my $cd_step = 0.5;
my $inflation_value = 1.5;

GetOptions(

	'help|?' 	=> \$help,
	'man' 		=> \$man,
	'input=s' 	=> \$input_file,
	'output=s'	=> \$output_dir,
	'threads=i'	=> \$threads,
	'steps=s'	=> \$steps,
	'perc=s'	=> \$perc,
	'cdlow|cdl=i' => \$cd_low,
	'cdstep|cds=f' => \$cd_step,
	'flat=f' 	=> \$inflation_value,
	'loci=s' 		=> \$loci_list,
	'quiet'		=> \$quiet,
	'retain' => \$retain,
	'nucleotide' => \$nucleotide,
	
) or pod2usage(2);
pod2usage(1) if $help;
pod2usage(-verbose => 2) if $man;

# expand input and output files/directories
$input_file = abs_path($input_file);
my $input_dir = dirname(abs_path($input_file));
$output_dir = $input_dir if $output_dir eq '';
$output_dir = abs_path($output_dir);

# make output directory if it doesn't exist. 
if( -d "$output_dir" ){ }
else{ unless ( mkdir "$output_dir" ) { die "could not make working directory in $output_dir\n" } }

# check for mandatory input arguments
pod2usage( {-message => q{input directory is a required arguement}, -exitval => 1, -verbose => 1 } ) if $input_dir eq ''; 

# check for presence of input/output directories.
pod2usage( {-message => "input directory:$input_dir is not a directory", -exitval => 1, -verbose => 1 } ) unless -d $input_dir; 
pod2usage( {-message => "output directory:$output_dir is not a directory", -exitval => 1, -verbose => 1 } ) unless -d $output_dir; 

# working variables
my @files = ($input_file);
my $no_files = scalar(@files);
my $sample = "";

# identify thresholds and check they are numeric
my @thresholds = ();
if( $steps eq "" ){ 
	@thresholds = ($perc);
}
else{ 
	@thresholds = split (/\,/, $steps);
	@thresholds = sort  {$a <=> $b} @thresholds;
}
for (@thresholds) { if ( $_ !~ /^\d+$/ ) { die "Threshold value $_ is not numeric.\n" } }

# check files exist and have correct suffix.
my @suffix_list = (".aa.fasta" , ".fasta" , ".fa" , ".fas");
for my $file( @files ){

	my $suffix_check = 0;
	for (@suffix_list){ $suffix_check = 1 if $file =~ /$_$/  }
	die "$file suffix not recognised\n" if $suffix_check == 0;

	die "file $file does not exist.\n" if !-f $file;
		
} 

# check for conflicts between cd-hit low and %id threshold
my $max_thresh = $thresholds[scalar(@thresholds)-1];
die "Lowest cd-hit threshold ($cd_low) is below blast % id value ($max_thresh)" if $cd_low < $max_thresh;

# parse and check loci list if passed via -l
my %loci;
my $no_loci = 0;
my $no_genomes = 0;
if( $loci_list ne '' ){
	$loci_list = abs_path($loci_list);
	die "loci_list file not found.\n" unless -f $loci_list;
	open LOCI, "$loci_list" or die $!;
	while (<LOCI>){	
		if(/^(\S+)\t(\S+)\t/){ 
			$loci{$1}=$2;
		}
	}	
	$no_loci = scalar ( keys(%loci) );
	my %no_g = map {$_ => 1} values(%loci);
	$no_genomes =  scalar( keys (%no_g) );
}

# user feedback
if ($quiet == 0 ){
	print "Creating pangenome on nucleotide % identity.\n" if $nucleotide == 1;
	print "Creating pangenome on amino acid % identity.\n" if $nucleotide == 0;
	print "Input directory:\t$input_dir\n";
	print "Output directory:\t$output_dir\n";
	print "Number of input files: $no_files\n";
	print "Threshold(s): @thresholds\n";
	print "MCL inflation value: $inflation_value\n";
	print "Loci file contains $no_loci loci from $no_genomes genomes.\n" if $loci_list ne '';
	print "\n";
}

# variables for user feedback
my $processed = 0;
my $no_processed = 0;

# timer sub
my $time = time();
sub time_update {
	my $time_diff = time() - $time;
	print " - completed in $time_diff secs\n";
	$time = time();
}

# process files sequentially
for my $file( @files ){

	++$processed;	
	
	# find sample name
	my ($sample, $s_path, $suffix) = fileparse($file , @suffix_list);
		
	# create core file.
	my %core = ();
	`echo -n "" > $output_dir/$sample.core_clusters.tab`;
	die "cdhit failed.\n" if $?;
			
	# feedback
	print " - Opening $sample\n" if $quiet == 0;
	
	# make temp fasta sequence without alignment characters and single line.
	my @seq = ();
	my @seq_out = ();
	my $header = "";
	my @g_lengths = ();
	my $temp_seq = "";

	open FILE, "$file" or die "$file not found.\n";
	while(<FILE>){
		
		my $line = $_;
		$line =~ s/\R//g;
				
		if(/^>/){
						
			unless( scalar(@seq) == 0 ){
				$temp_seq = join( "" , @seq );
				push ( @seq_out, join("\n" , $header , $temp_seq) );
				push ( @g_lengths, length($temp_seq) );
			}	
				
			$header = $line;	
			@seq = ();
			
		}else{
		
			$line =~ s/\-//g;
			push( @seq, $line );
			
		}
	}close FILE;
	
	# store final sample
	$temp_seq = join("" , @seq);
	push ( @seq_out, join("\n" , $header , $temp_seq) );
	push ( @g_lengths, length( $temp_seq ));

	# sort file on length.
	my @idx = sort { $g_lengths[$b] <=> $g_lengths[$a] } 0 .. $#g_lengths;
	
	# Print to all sequences file.
	open TEMP, ">$output_dir/$sample.all_sequences.fasta" or die $!;
	print TEMP join("\n", @seq_out[@idx]);
	
	# number of sequences in file.
	my $no_sequences = scalar ( @seq_out ); 
	
	# cluster files using CD-Hit.
	my %cluster_hash = ();
	my %seq_length = (); 
	
	# make cd-hit log file.
	my $cdhit_log = "$output_dir/$sample.cdhit_log.txt";
	open CD_LOG, ">$cdhit_log" or die $!;
	
	# run at multiple thresholds.
	`cp $output_dir/$sample.all_sequences.fasta $output_dir/$sample.temp.fasta`;
	my $no_reduced = 0;
	print " - running cd hit on $sample" if $quiet == 0;
	for (my $i = 100; $i >= $cd_low; $i -= $cd_step) {	   		 
	
		my $curr_thresh = $i/100;
		
		# calculate memory for cdhit
		my $m_required = -s "$output_dir/$sample.temp.fasta";
		$m_required = int($m_required/1000000); #Mb
		$m_required *= 3; # triple
		$m_required = 2000 if($m_required < 2000); # set lowest
		
		# run cdhit
		print " - running cd hit on $sample at $i   \n" if $quiet == 0;
		if( $nucleotide == 0 ){
			`$cd_hit_bin -i $output_dir/$sample.temp.fasta -o $output_dir/$sample.$i -c $curr_thresh -T $threads -c 1 -g 1 -n 5 -M $m_required -d 256 >> $cdhit_log`;
		}else{
			`$cd_hit_est_bin -i $output_dir/$sample.temp.fasta -o $output_dir/$sample.$i -c $curr_thresh -T $threads -c 1 -g 1 -n 5 -M $m_required -d 256 >> $cdhit_log`;
		}
		die "cdhit failed.\n" if $?;
		time_update();

		# variables
		my $define = 0;
		my @include_seq = ();
		
		my $c_name = "";
		
		print " - parsing clstr file.\n";
		open CLUSTER, "$output_dir/$sample.$i.clstr" or die $!;
		while(<CLUSTER>){
	
			# Add clustered loci to storage hash.
			if(/^>Cluster\s(\d+)*/){

				$c_name = $1+1;

			}elsif( /^\d+\s+(\d+)(aa|nt)\,\s+>(.+)\.\.\./ ){ 
			
				# sanity check 
				die "cdhit header error\n" if $c_name eq "";
				
				# cluster hash
				$cluster_hash {$3} = $c_name;
				
				# length of seq
				$seq_length {$3} = $1;				
										
			}else{
				die "$_ did not match cd-hit format.\n";
			}
			
		}
		time_update();
		
		# check for gene clusters in 100% of genomes - remove as core.
		print " - checking core clusters.\n";
		if( $loci_list ne '' ){
			
			# variables
			my %cluster_genomes = ();
			my %cluster_count = ();
			
			# count no of genes and no of genomes
			for my $l( keys %cluster_hash ){
		
				die "no genome found for loci $l\n" if !$loci{$l};
				$cluster_genomes { $cluster_hash{$l} }{ $loci{$l} }++;
				$cluster_count { $cluster_hash{$l} } { $l } = 1 ;
				
			}			
			
			# Identify core clusters.
			open CORE2, ">>$output_dir/$sample.core_clusters.tab" or die "couldn't open $sample.core_clusters.tab\n";
			for my $lc ( keys %cluster_genomes ){
				
				my $c_count = scalar(keys($cluster_genomes{$lc}));
				my $g_count = scalar(keys($cluster_count{$lc}));
				
				if( ( $c_count == $no_genomes ) && ( $g_count == $no_genomes) ){
					
					# add to core_clusters.tab file.					
					my $core_out = join ( "\t" , keys(%{$cluster_count{$lc}}));
					print CORE2 "$core_out\n";
					
					# add to core_hash and remove from cluster hash.
					foreach ( keys %{$cluster_count{$lc}} ){
						$core{$_} = $lc;
						delete $cluster_hash{$_};
					}
					
			
				}
				
			}close CORE2;			
			
		}
		time_update();
		
		# make array of locus tags
		@include_seq = keys %cluster_hash;
		
		open INCLUDE, ">$output_dir/$sample.$i.include" or die $!; 
		print INCLUDE join("\n", @include_seq),"\n";
		
		# create new working fasta 
		my $f_header = "";
		my $sample_check = 0;
		open FASTA_IN, "$output_dir/$sample.all_sequences.fasta" or die "$file not found.\n";
		open FASTA_OUT, ">$output_dir/$sample.temp.fasta" or die "$file not found.\n";
		while(<FASTA_IN>){
		
			my $line = $_;
			$line =~ s/\R//g;
				
			if(/^\>(\S+)*/){
			
				$header = $1;
				
			}else{
		
				if( $cluster_hash{ $header } ){
					print FASTA_OUT ">$header\n$line\n";
					++$sample_check;
				}
			}
		}
		close FASTA_IN;
		close FASTA_OUT;
		die "Number of samples in $output_dir/$sample.temp.fasta does not match number of included loci.\n" if $sample_check != scalar(keys(%cluster_hash));
		time_update();

		`mv $output_dir/$sample.$i.include $output_dir/$sample.included`;
	
	}
	close CD_LOG;
	print "\n" if $quiet == 0;
	
	# aggregate clusters for analysis 
	my %cluster_loci = ();
	for my $lh( keys %cluster_hash ){

		$cluster_loci{ "$cluster_hash{$lh}" } { $lh } = $seq_length{ $lh };

	}
	
	# open file for cluster file.
	`echo -n  "" > $output_dir/$sample.clusters`;
	die "could not open $output_dir/$sample.clusters" if $?;
	
	#  Select longest isolate as representative of cluster for blast.
	print " - select rep seqs\n";
	my %rep_seqs = ();
	for my $ch1 ( keys %cluster_loci ) {
		
		# find longest representative sequence.
		my $rep = "";
		my $tl = 0;
		for my $ch2 ( sort { $cluster_loci{$ch1}{$b}<=>$cluster_loci{$ch1}{$a}} keys %{$cluster_loci{$ch1}} ){			
			$rep = $ch2;
			last;
		}
		
		# print to cluster storage file.
		my $print_line = sprintf( "$rep\t-\t%s", join ( "\t", keys(%{$cluster_loci{$ch1}}) ) );
		`echo $print_line >> $output_dir/$sample.clusters`;

		# add to rep array
		$rep_seqs {$rep} = 1;
		
	}
	
	# create new working fasta 
	my $f_header = "";
	my $sample_check = 0;
	open FASTA_IN, "$output_dir/$sample.all_sequences.fasta" or die "$file not found.\n";
	open FASTA_OUT, ">$output_dir/$sample.blast.input" or die "$file not found.\n";
	while(<FASTA_IN>){
	
		my $line = $_;
		$line =~ s/\R//g;
			
		if(/^>(\S+)*/){
					
			$header = $1;
		
		}else{
	
			if( $rep_seqs {$header} ){
				print FASTA_OUT ">$header\n$line\n";
				++$sample_check;
			}
		
		}
	}
	close FASTA_IN;
	close FASTA_OUT;
	die "Number of samples in $output_dir/$sample.blast.input does not match number of included loci.\n" if $sample_check != scalar(keys(%rep_seqs));
	time_update();
		
	# check number of stored clusters equals number of starting sequences.
	my $core_cluster_no = scalar ( keys %core );
	my $check_clusters = scalar keys ( %cluster_hash );
	my $total_clusters = $core_cluster_no + $check_clusters;
	print " - $core_cluster_no core loci (",(($core_cluster_no/$total_clusters)*100), "%)\n" unless $quiet == 1;
	die "number of sequences clustered via cd-hit (", ($check_clusters+$core_cluster_no) ,") does not match number of input sequences ($no_sequences)" if ($check_clusters+$core_cluster_no) != $no_sequences;
	
	# feedback
	print " - ", scalar (keys %cluster_loci), " loci passed to blast.\n";
	
	# all vs all blast
	my $blast_in = "$output_dir/$sample.blast.input";
	my $blast_out = "$output_dir/$sample.blast.output";
	
	if( $nucleotide == 0 ){
	
		print " - running all-vs-all blastp on $sample\n" if $quiet == 0;
		`makeblastdb -in $blast_in -dbtype prot`;
		`$blastp_bin -task "blastp" -outfmt 6 -num_threads $threads -max_hsps 1 -query $blast_in -db $blast_in -out $blast_out`; # -evalue 1E-6 -max_target_seqs 2000
		die "blastp failed.\n" if $?;
	
	}else{
	
		print " - running all-vs-all blastn on $sample\n" if $quiet == 0;
		`makeblastdb -in $blast_in -dbtype nucl`;
		`$blastn_bin -task "blastn" -outfmt 6 -num_threads $threads -dust no -max_hsps 1 -query $blast_in -db $blast_in -out $blast_out`; # -evalue 1E-6 -max_target_seqs 2000
		die "blastn failed.\n" if $?; 
		
	}
	time_update();
	
	# Filter BLAST files at all thresholds and perform MCL on filtered hits.
	# Iterate through all clusters at higher thresholds.
	print " - running mcl on $sample" if $quiet == 0;
	my $previous_clusters = ""; 
	for my $c(0..(scalar(@thresholds)-1) ){
	
		my $threshold = $thresholds[$c];
		
		# feedback
		print " - running mcl on $sample at $threshold    \n" if $quiet == 0;
		
		# filter blast results on threshold.
		`awk '{if(\$3 >= $threshold){print \$0}}' < $blast_out > $output_dir/$sample.$threshold.blast`;
				
		if( $threshold ==  $thresholds[0] ){
	
			# reformat to abc and run mcl on bitscores normalised by hsp length
			`$mcxdeblast_bin --line-mode=abc --m9 --score=r $output_dir/$sample.$threshold.blast 2>/dev/null | $mcl_bin - --abc -te $threads -I $inflation_value -o $output_dir/$sample.mcl_$threshold.clusters 2>/dev/null`;
			die "mcl failed at $threshold" if $?;
			
			# set working file for next iteration
			$previous_clusters = "$output_dir/$sample.mcl_$threshold.clusters";
		
		}else{
		
			# make mcl cluster file.
			`echo -n "" > $output_dir/$sample.mcl_$threshold.clusters`;
			
			# run mcl on each subcluster independently.
			my $cluster_no = 0;
			my %l_hash = ();
			open CLUSTERS, "$output_dir/$sample.mcl_$thresholds[$c-1].clusters" or die $!;
			while (<CLUSTERS>){
			
				$cluster_no++;
			
				my $line = $_;
				chomp $line;
								
				my @loci = split(/\s+/, $line);
				foreach( @loci ){ $l_hash{$_} = $cluster_no };
				
			}
			
			# filter blast output into multiple temp cluster files.
			mkdir( "$output_dir/mcl_sub/" ) or die $1;
			open BLAST, "$output_dir/$sample.$threshold.blast" or die $!;
			while(<BLAST>){
			
				my $b_line = $_;
			
				if(/^(\S+)\s+(\S+)\s+/){					
								
					if( $l_hash{$1} == $l_hash{$2} ){
						open BLAST_SUB, ">$output_dir/mcl_sub/cluster_$l_hash{$1}.blast" or die $!;
						print BLAST_SUB $b_line ;
						close BLAST_SUB;
					}

				}
				
			}close BLAST;
			
			# make temp file for parallel
			
			# mcl 
			
				
			exit;
				
			# run mcl on sub-sampled abc blast file.
			`$mcxdeblast_bin --line-mode=abc --m9 --score=r $output_dir/$sample.$threshold.temp_sub.blast 2>/dev/null | $mcl_bin - --abc -te $threads -I $inflation_value -o $output_dir/$sample.mcl_$threshold.temp.clusters 2>/dev/null`;
			die "mcl failed at $threshold - line:\n$line\n" if $?;
			
			# add to existing file
			#`cat $output_dir/$sample.mcl_$threshold.clusters $output_dir/$sample.mcl_$threshold.temp.clusters > $output_dir/temp.txt`;
			#`mv $output_dir/temp.txt $output_dir/$sample.mcl_$threshold.clusters`;
			#unlink "$output_dir/$sample.mcl_$threshold.temp.clusters";
			
			# set working file for next iteration
			$previous_clusters = "$output_dir/$sample.mcl_$threshold.clusters";
						
			#close CLUSTERS;
			
		}
		time_update();
	}
	print "\n" if $quiet == 0;
	
	# Reinflate clusters
	print " - reinflating clusters for $sample" if $quiet == 0;
	for my $t(@thresholds){
		
		# open output
		open INFLAT, ">$output_dir/$sample.$t.reclustered.reinflated" or die $!;
		
		# open input
		open CR, "$output_dir/$sample.mcl_$t.clusters" or die $!;

		# sanity check on number of output sequences.
		my $seq_count = 0;
		
		# loop through all clusters and reinflate where appropriate.
		while (<CR>){
			
			my $line = $_;
			$line =~ s/\R//;
			
			my @clusters_reinflated = ();

			foreach my $inflat( split(/\t/ , $line) ){
				
				# if cluster was previously deflated with cd-hit add in missing loci.				
				die "Error $inflat not in a cdhit cluster.\n" if !$cluster_hash{$inflat} ;
					
				my $index  = $cluster_hash{$inflat};	
				foreach( keys %{$cluster_loci{$index}} ){
					push( @clusters_reinflated, $_);
					++$seq_count;
				}					
				
			}
			
			# print to file.
			print INFLAT join ("\t", @clusters_reinflated), "\n";			

		}				
		close INFLAT;
		close CR;
		
		# add core clusters
		`cat $output_dir/$sample.core_clusters.tab $output_dir/$sample.$t.reclustered.reinflated > $output_dir/temp.txt`;
		`mv $output_dir/temp.txt $output_dir/$sample.$t.reclustered.reinflated`;
		#unlink "$output_dir/temp.txt";
		
		# check number of clusters in final file matches input.
		die "Reinflated sequences (", ($seq_count+$core_cluster_no) , ") does not match input number of sequences ($no_sequences) at $t threshold in sample $sample.\n" if ($seq_count+$core_cluster_no) != $no_sequences;
		
	}
	
	# clean up temporary files
	unless ( $retain == 1 ){
	
		unlink "$output_dir/$sample.all_sequences.fasta";
		unlink "$output_dir/$sample.included";
		unlink "$output_dir/$sample.cdhit_log.txt";
		unlink "$output_dir/$sample.blast.input";
		unlink "$output_dir/$sample.blast.output";
		unlink "$output_dir/$sample.clusters";
		unlink "$output_dir/$sample.temp.fasta";
		
		if ( $nucleotide == 0 ){
			unlink "$output_dir/$sample.blast.input.phr";
			unlink "$output_dir/$sample.blast.input.pin";
			unlink "$output_dir/$sample.blast.input.psq";
		}else{
			unlink "$output_dir/$sample.blast.input.nhr";
			unlink "$output_dir/$sample.blast.input.nin";
			unlink "$output_dir/$sample.blast.input.nsq";
		}
	
		for (@thresholds){ 
			unlink "$output_dir/$sample.$_.blast";
			unlink "$output_dir/$sample.$_.temp_sub.blast";
			unlink "$output_dir/$sample.mcl_$_.clusters";
			unlink "$output_dir/$sample.mcl_$_.temp.clusters" if -f "$output_dir/$sample.mcl_$_.temp.clusters";
		}
	
		for (my $j = 100; $j >= $cd_low; $j -= $cd_step) {	
			unlink "$output_dir/$sample.$j";
			unlink "$output_dir/$sample.$j.clstr";
	
		}
		
	}
	
}
print "\n - Finished\n" if $quiet == 0;


exit
