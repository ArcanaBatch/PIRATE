#!/usr/bin/env perl

# Pangenome construction using cd-hit to deflate clusters, all-vs-all BLAST, nested/single MCL clustering and reinflation.

use strict;
use warnings;

use Getopt::Long qw(GetOptions);
use Pod::Usage;
use Cwd 'abs_path';
use File::Basename;

# check dependencies - no version check.
my $cd_hit_bin = "";
my $cd_hit_est_bin = "";
my $blastp_bin = "";
my $blastn_bin = "";
my $mcl_bin = "";
my $make_blast = "";
my $mcxdeblast_bin = "";

$cd_hit_bin = "cdhit" if `command -v cdhit;`;
$cd_hit_bin = "cd-hit" if `command -v cd-hit;`;
$cd_hit_est_bin = "cd-hit-est" if `command -v cd-hit-est;`;
$cd_hit_est_bin = "cdhit-est" if `command -v cdhit-est;`;
$blastp_bin = "blastp" if `command -v blastp;`;
$blastn_bin = "blastn" if `command -v blastn;`;
$make_blast = "makeblastdb" if `command -v makeblastdb;`;
$mcl_bin = "mcl" if `command -v mcl;`;
$mcxdeblast_bin = "mcxdeblast" if `command -v mcxdeblast;`;

my $dep_err = 0;
foreach( $cd_hit_bin, $blastn_bin, $blastp_bin , $mcl_bin, $cd_hit_est_bin){
	if($_ eq "") { print "$_ command not found.\n"; $dep_err = 1 }
}
die "Dependencies missing.\n" if $dep_err == 1;

# Version

=head1  SYNOPSIS

	pangenome_construction.pl -i /path/to/fasta 

=head1 Descriptions
	
	-h|--help 			usage information
	-m|--man			man page 
	-i|--input			input fasta file [nucleotide/aa]
	-o|--output			output directory [default: input directory]
	-t|--threads		number of threads/cores used to use [default: 2]
	-s|--steps			% identity threshold to use for pangenome construction [default: 95]
	-p|--perc			% identity thresholds to use for pangenome construction [default: 50,60,70,80,90,95,98]
	-l|--loci			file containing loci and genome as seperate columns [required for core extraction during cdhit]
	-q|--quiet			switch off verbose
	-cdl|--cdlow		cdhit lowest percentage id [default: 98]
	-cds|--cdstep		cdhit step size [default: 0.5]
	-f|--flat			mcl inflation value [default:2]
	-r|--retain			do not delete temp files
	-n|--nucleotide		create pangenome on nucleotide sequence [default: amino acid]
	
...

=cut

# path to executing script
my $script_path = abs_path(dirname($0));

# switch off buffering
$| = 1; # turn off buffering for real time feedback.

# command line options
my $man = 0;
my $help = 0;
my $quiet = 0;
my $retain = 0;
my $nucleotide = 0;
my $threads = 2; 

my $input_file = '';
my $output_dir = '';
my $loci_list = '';

my $perc = 95;
my $steps = '';
my $cd_low = 98;
my $cd_step = 0.5;
my $inflation_value = 1.5;

GetOptions(

	'help|?' 	=> \$help,
	'man' 		=> \$man,
	'input=s' 	=> \$input_file,
	'output=s'	=> \$output_dir,
	'threads=i'	=> \$threads,
	'steps=s'	=> \$steps,
	'perc=s'	=> \$perc,
	'cdlow|cdl=i' => \$cd_low,
	'cdstep|cds=f' => \$cd_step,
	'flat=f' 	=> \$inflation_value,
	'loci=s' 		=> \$loci_list,
	'quiet'		=> \$quiet,
	'retain' => \$retain,
	'nucleotide' => \$nucleotide,
	
) or pod2usage(2);
pod2usage(1) if $help;
pod2usage(-verbose => 2) if $man;

# expand input and output files/directories
$input_file = abs_path($input_file);
my $input_dir = dirname(abs_path($input_file));
$output_dir = $input_dir if $output_dir eq '';
$output_dir = abs_path($output_dir);

# make output directory if it doesn't exist. 
if( -d "$output_dir" ){ }
else{ unless ( mkdir "$output_dir" ) { die "could not make working directory in $output_dir\n" } }

# check for mandatory input arguments
pod2usage( {-message => q{input directory is a required arguement}, -exitval => 1, -verbose => 1 } ) if $input_dir eq ''; 

# check for presence of input/output directories.
pod2usage( {-message => "input directory:$input_dir is not a directory", -exitval => 1, -verbose => 1 } ) unless -d $input_dir; 
pod2usage( {-message => "output directory:$output_dir is not a directory", -exitval => 1, -verbose => 1 } ) unless -d $output_dir; 

# working variables
my @files = ($input_file);
my $no_files = scalar(@files);
my $sample = "";

# identify thresholds and check they are numeric
my @thresholds = ();
if( $steps eq "" ){ 
	@thresholds = ($perc);
}
else{ 
	@thresholds = split (/\,/, $steps);
	@thresholds = sort  {$a <=> $b} @thresholds;
}
for (@thresholds) { if ( $_ !~ /^\d+$/ ) { die "Threshold value $_ is not numeric.\n" } }

# check files exist and have correct suffix.
my @suffix_list = (".aa.fasta" , ".fasta" , ".fa" , ".fas");
for my $file( @files ){

	my $suffix_check = 0;
	for (@suffix_list){ $suffix_check = 1 if $file =~ /$_$/  }
	die "$file suffix not recognised\n" if $suffix_check == 0;

	die "file $file does not exist.\n" if !-f $file;
		
} 

# check for conflicts between cd-hit low and %id threshold
my $max_thresh = $thresholds[scalar(@thresholds)-1];
die "Lowest cd-hit threshold ($cd_low) is below blast % id value ($max_thresh)" if $cd_low < $max_thresh;

# parse and check loci list if passed via -l
my %loci;
my $no_loci = 0;
my $no_genomes = 0;
if( $loci_list ne '' ){
	$loci_list = abs_path($loci_list);
	die "loci_list file not found.\n" unless -f $loci_list;
	open LOCI, "$loci_list" or die $!;
	while (<LOCI>){	
		if(/^(\S+)\t(\S+)\t/){ 
			$loci{$1}=$2;
		}
	}	
	$no_loci = scalar ( keys(%loci) );
	my %no_g = map {$_ => 1} values(%loci);
	$no_genomes =  scalar( keys (%no_g) );
}

# user feedback
if ($quiet == 0 ){
	print "Creating pangenome on nucleotide % identity.\n" if $nucleotide == 1;
	print "Creating pangenome on amino acid % identity.\n" if $nucleotide == 0;
	print "Input directory:\t$input_dir\n";
	print "Output directory:\t$output_dir\n";
	print "Number of input files: $no_files\n";
	print "Threshold(s): @thresholds\n";
	print "MCL inflation value: $inflation_value\n";
	print "Loci file contains $no_loci loci from $no_genomes genomes.\n" if $loci_list ne '';
	print "\n";
}

# variables for user feedback
my $processed = 0;
my $no_processed = 0;

# timer sub
my $time = time();
sub time_update {
	my $time_diff = time() - $time;
	print " - completed in $time_diff secs\n";
	$time = time();
}

# process files sequentially
for my $file( @files ){

	++$processed;	
	
	# find sample name
	my ($sample, $s_path, $suffix) = fileparse($file , @suffix_list);
		
	# create core file.
	my %core = ();
	`echo -n "" > $output_dir/$sample.core_clusters.tab`;
	die "cdhit failed.\n" if $?;
			
	# feedback
	print " - Opening $sample\n" if $quiet == 0;
	
	# make temp fasta sequence without alignment characters and single line.
	my @seq = ();
	my @seq_out = ();
	my $header = "";
	my @g_lengths = ();
	my $temp_seq = "";

	open FILE, "$file" or die "$file not found.\n";
	while(<FILE>){
		
		my $line = $_;
		$line =~ s/\R//g;
				
		if(/^>/){
						
			unless( scalar(@seq) == 0 ){
				$temp_seq = join( "" , @seq );
				push ( @seq_out, join("\n" , $header , $temp_seq) );
				push ( @g_lengths, length($temp_seq) );
			}	
				
			$header = $line;	
			@seq = ();
			
		}else{
		
			$line =~ s/\-//g;
			push( @seq, $line );
			
		}
	}close FILE;
	
	# store final sample
	$temp_seq = join("" , @seq);
	push ( @seq_out, join("\n" , $header , $temp_seq) );
	push ( @g_lengths, length( $temp_seq ));

	# sort file on length.
	my @idx = sort { $g_lengths[$b] <=> $g_lengths[$a] } 0 .. $#g_lengths;
	
	# Print to all sequences file.
	open TEMP, ">$output_dir/$sample.all_sequences.fasta" or die $!;
	print TEMP join("\n", @seq_out[@idx]);
	
	# number of sequences in file.
	my $no_sequences = scalar ( @seq_out ); 
	
	# cluster files using CD-Hit.
	my %cluster_hash = ();
	my %seq_length = (); 
	
	# make cd-hit log file.
	my $cdhit_log = "$output_dir/$sample.cdhit_log.txt";
	open CD_LOG, ">$cdhit_log" or die $!;
	
	# run at multiple thresholds.
	`cp $output_dir/$sample.all_sequences.fasta $output_dir/$sample.temp.fasta`;
	my $no_reduced = 0;
	print " - running cd hit on $sample" if $quiet == 0;
	for (my $i = 100; $i >= $cd_low; $i -= $cd_step) {	   		 
	
		my $curr_thresh = $i/100;
		
		# calculate memory for cdhit
		my $m_required = -s "$output_dir/$sample.temp.fasta";
		$m_required = int($m_required/1000000); #Mb
		$m_required *= 3; # triple
		$m_required = 2000 if($m_required < 2000); # set lowest
		
		# run cdhit
		print " - running cd hit on $sample at $i   \n" if $quiet == 0;
		if( $nucleotide == 0 ){
			`$cd_hit_bin -i $output_dir/$sample.temp.fasta -o $output_dir/$sample.$i -c $curr_thresh -T $threads -c 1 -g 1 -n 5 -M $m_required -d 256 >> $cdhit_log`;
		}else{
			`$cd_hit_est_bin -i $output_dir/$sample.temp.fasta -o $output_dir/$sample.$i -c $curr_thresh -T $threads -c 1 -g 1 -n 5 -M $m_required -d 256 >> $cdhit_log`;
		}
		die "cdhit failed.\n" if $?;
		time_update();

		# variables
		my $define = 0;
		my @include_seq = ();
		
		my $c_name = "";
		
		print " - parsing clstr file.\n";
		open CLUSTER, "$output_dir/$sample.$i.clstr" or die $!;
		while(<CLUSTER>){
	
			# Add clustered loci to storage hash.
			if(/^>Cluster\s(\d+)*/){

				$c_name = $1+1;

			}elsif( /^\d+\s+(\d+)(aa|nt)\,\s+>(.+)\.\.\./ ){ 
			
				# sanity check 
				die "cdhit header error\n" if $c_name eq "";
				
				# cluster hash
				$cluster_hash {$3} = $c_name;
				
				# length of seq
				$seq_length {$3} = $1;				
										
			}else{
				die "$_ did not match cd-hit format.\n";
			}
			
		}
		time_update();
		
		# check for gene clusters in 100% of genomes - remove as core.
		print " - checking core clusters.\n";
		if( $loci_list ne '' ){
			
			# variables
			my %cluster_genomes = ();
			my %cluster_count = ();
			
			# count no of genes and no of genomes
			for my $l( keys %cluster_hash ){
		
				die "no genome found for loci $l\n" if !$loci{$l};
				$cluster_genomes { $cluster_hash{$l} }{ $loci{$l} }++;
				$cluster_count { $cluster_hash{$l} } { $l } = 1 ;
				
			}			
			
			# Identify core clusters.
			open CORE2, ">>$output_dir/$sample.core_clusters.tab" or die "couldn't open $sample.core_clusters.tab\n";
			for my $lc ( keys %cluster_genomes ){
				
				my $c_count = scalar(keys($cluster_genomes{$lc}));
				my $g_count = scalar(keys($cluster_count{$lc}));
				
				if( ( $c_count == $no_genomes ) && ( $g_count == $no_genomes) ){
					
					# add to core_clusters.tab file.					
					my $core_out = join ( "\t" , keys(%{$cluster_count{$lc}}));
					print CORE2 "$core_out\n";
					
					# add to core_hash and remove from cluster hash.
					foreach ( keys %{$cluster_count{$lc}} ){
						$core{$_} = $lc;
						delete $cluster_hash{$_};
					}
					
			
				}
				
			}close CORE2;			
			
		}
		time_update();
		
		# make array of locus tags
		@include_seq = keys %cluster_hash;
		
		open INCLUDE, ">$output_dir/$sample.$i.include" or die $!; 
		print INCLUDE join("\n", @include_seq),"\n";
		
		# create new working fasta 
		my $f_header = "";
		my $sample_check = 0;
		open FASTA_IN, "$output_dir/$sample.all_sequences.fasta" or die "$file not found.\n";
		open FASTA_OUT, ">$output_dir/$sample.temp.fasta" or die "$file not found.\n";
		while(<FASTA_IN>){
		
			my $line = $_;
			$line =~ s/\R//g;
				
			if(/^\>(\S+)*/){
			
				$header = $1;
				
			}else{
		
				if( $cluster_hash{ $header } ){
					print FASTA_OUT ">$header\n$line\n";
					++$sample_check;
				}
			}
		}
		close FASTA_IN;
		close FASTA_OUT;
		die "Number of samples in $output_dir/$sample.temp.fasta does not match number of included loci.\n" if $sample_check != scalar(keys(%cluster_hash));
		time_update();

		`mv $output_dir/$sample.$i.include $output_dir/$sample.included`;
	
	}
	close CD_LOG;
	
}
print "\n - Finished\n" if $quiet == 0;


exit
